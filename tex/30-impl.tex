\chapter{Технологическая часть}

В данном разделе представлены средства разработки программного обеспечения, детали реализации и тестирование функций.

\section{Выбор языка программирования и среды разработки}
Существует множество языков, а также сред программирования, многие из которых обладают достаточно высокой эффективностью, удобством и простотой в использовании. Для разработки данной программы был выбран язык C\# \cite{csharplang}. Данный выбор обусловлен следующими факторами.

\begin{enumerate}
	\item Этот язык предоставляет программисту широкие возможности реализации самых разнообразных алгоритмов. Он обладает высокой эффективностью и большим набором стандартных классов и процедур.
	\item C\# является полностью объектно-ориентированным. Он позволяет использовать множественное наследование, абстрактные и параметризованные классы.
	\item Язык является строго типизированным, что позволяет защититься от неконтролируемых  ошибок.
	\item В данном языке имеется большое количество библиотек и шаблонов, позволяющих не тратить время на изобретение готовых конструкций.
\end{enumerate}

В качестве среды разработки была выбрана Visual Studio 2019. Некоторые факторы по которым была выбрана данная среда.
\begin{enumerate}
	\item Включает весь основной функционал: параллельная сборка, отладчик, поддержка точек останова, сборки и т.д.
	\item Разработчики имеют возможность расширить любой функционал, включая компиляцию, отладку.
	\item Работает с интерфейсом Windows Forms, который очень удобен в использовании, а также позволяет без проблем создавать приложения.
\end{enumerate}

\section{Структура программы}
Так как при написании программы используется язык C\#, а это объектно-ориентированный язык, то особое внимание уделено структуре классов.

Условно классы в программе можно разделить на несколько групп по выполняемым функциям.

\begin{itemize}
	\item Математические абстракции
	\begin{itemize}
		\item Trace - структура, в которую входит точка пересечения луча с объектом расстояние от камеры до точки пересечения
		\item Ray - трехмерный луч, задающийся точкой начала луча, направляющим вектором
		\item Comparator - помогает сравнивать сегменты молнии
	\end{itemize}
	\item Вспомогательные классы свойств трехмерных объектов
	\begin{itemize}
		\item Texture - абстрактный класс с основными свойствами.
		\item SimpleTexture и VectorTexture - обеспечивают загрузку из файла текстуры, ее интерпретацию на простую поверхность
	\end{itemize}
	\item Трехмерные объекты
	\begin{itemize}
		\item House – реализует работу с домом, генерацию, трехмерные преобразования
		\item Lightning – реализует работу с молнией, генерацию, трёхмерные преобразования.
	\end{itemize}
	\item Источники света
	\begin{itemize}
		\item Shadow - класс, позволяющий работать с тенями. Одним из ключевых механизмов базового алгоритма обратной трассировки лучей является метод теневых лучей, позволяющие реализовать тени от загораживающих источники света объектов.
	\end{itemize}
	\item Сцена
	\begin{itemize}
		\item Scene - характеризует набор объектов и их свойств. Следует обратить внимание на то, что сцена использует динамические объекты, что позволяет уже после загрузки и построения сцены изменить ее состав (удалять/добавлять/изменять компоненты).
	\end{itemize}
	\item Алгоритмы визуализации
	\begin{itemize}
		\item Highlight - отрисовка вспышки
		\item Lightning - отрисовка молнии
		\item House - отрисовка дома
		\item Shadow - отрисовка тени
		\item Texture - отрисовка текстуры
		\item Window - отрисовка окна
	\end{itemize}
	\item Интерфейс пользователя
	\begin{itemize}
		\item Взаимодействие с интерфейсом происходит через диалоговые окна, которые в свою очередь взаимодействуют с классом Scene
	\end{itemize}	
\end{itemize}

На рисунке \ref{img:shema} представлена структура и состав классов.

\img{120mm}{shema}{Структура и состав классов}
\clearpage

\section{Разработка алгоритмов}
На листинге \ref{lst:raytrac} представлен оптимизированный алгоритм обратной трассировки лучей.


\begin{lstlisting}[label=lst:raytrac,caption=Реализация  оптимизированного алгоритма обратной трассировки лучей, language=c]
static public List<PointF> Reflection(Window w, double[] nor, Point3D p, Lightning lightning)
{
	var po = new Point3D(p.X, p.Y, -200);
	var no = new double[4];
	var refl = new List<PointF>();
	double r;
	
	float dx = w.Points[0].X - w.Points[3].X;
	float dy = w.Points[0].Y - w.Points[3].Y;
	float dz = w.Points[0].Z - w.Points[3].Z;
	
	float dx2 = w.Points[0].X - w.Points[1].X;
	float dy2 = w.Points[0].Y - w.Points[1].Y;
	float dz2 = w.Points[0].Z - w.Points[1].Z;
	
	double step = 1.0 / Math.Sqrt(dx * dx + dy * dy + dz * dz);
	
	nor.CopyTo(no, 0);
	for (int i = 0; i < 4; i++)
	{
		no[i] /= 100000;
	}
	
	for (r = 0.0; r <= 1; r = r + step)
	{
		var x = (float)(w.Points[3].X + r * dx + 0.5);
		var y = (float)(w.Points[3].Y + r * dy + 0.5);
		var z = (float)(w.Points[3].Z + r * dz + 0.5);
		float x2 = x + dx2;
		float y2 = y + dy2;
		float z2 = z + dz2;
		
		float dx3 = x2 - x;
		float dy3 = y2 - y;
		float dz3 = z2 - z;
		
		double step2 = 1.0 / Math.Sqrt(dx3 * dx3 + dy3 * dy3 + dz3 * dz3);
		double r2;
		
		for (r2 = 0.0; r2 <= 1; r2 = r2 + step2)
		{
			var x3 = (float)(x - r2 * dx3 + 0.5);
			var y3 = (float)(y - r2 * dy3 + 0.5);
			var z3 = (float)(z - r2 * dz3 + 0.5);
			
			var poi = new Point3D(x3 - po.X, y3 - po.Y, z3 - po.Z);
			double a = Math.Abs(no[0] * poi.X + no[1] * poi.Y + no[2] * poi.Z) /
				Math.Sqrt(no[0] * no[0] + no[1] * no[1] + no[2] * no[2]) /
				Math.Sqrt(poi.X * poi.X + poi.Y * poi.Y + poi.Z * poi.Z);
			
			a = Math.Asin(a);
			
			var os = new Point3D((float)(poi.Y * no[2] - poi.Z * no[1]),
				(float)(no[0] * poi.Z - poi.X * no[2]),
				(float)(poi.X * no[1] - poi.Y * no[0]));
			
			var vector = new Point3D();
			
			double cos = Math.Cos(a), sin = Math.Sin(a);
			
			vector.X = (float)(no[0] * (cos + (1 - cos) * os.X * os.X) + 
				no[1] * ((1 - cos) * os.Y * os.X + sin * os.Z) +
				no[2] * ((1 - cos) * os.Z * os.X - sin * os.Y));
			vector.Y = (float)(no[0] * (-sin * os.Z + (1 - cos) * os.X * os.Y) + 
				no[1] * ((1 - cos) * os.Y * os.Y + cos) +
				no[2] * ((1 - cos) * os.Z * os.Y + sin * os.X));
			vector.Z = (float)(no[0] * (sin * os.Y + (1 - cos) * os.X * os.Z) + 
				no[1] * ((1 - cos) * os.Y * os.Z - sin * os.X) +
				no[2] * ((1 - cos) * os.Z * os.Z + cos));
			
			var ray = new Ray(vector, new Point3D(x3, y3, z3));
			Trace t2 = lightning.TraceM(ray);
			
			if (t2.Dist != -1)
			{
				refl.Add(new PointF(x3, y3));
			}
		}
	}
	
	return refl;
}
\end{lstlisting}


\section{Интерфейс}
На рисунке \ref{img:inter} представлен интерфейс программы.

\img{8mm}{inter}{Интерфейс программы}

Функции представленных кнопок следующие:
\begin{itemize}
	\item кнопка ''Запустить/Оставновить'' -- запускает или выключает (останавливает) автоматическую генерацию молнии, непрерывно генерируются различные изображения;
	\item кнопка ''Визуализация'' -- создает одно изображение с указанной частотой включения и выключения света в окнах;
	\item кнопка ''Включить свет'' -- включает свет во всех окнах;
	\item кнопка ''Выключить свет'' -- выключает свет во всех окнах;
	\item кнопка ''Изменить количество этажей'' -- изменяет высоту дома (количество этажей), значение берется из поля слева, при этом генерируется новая сцена.
\end{itemize}

Также пользователь может взаимодействовать с программой при помощи стрелок вправо/влево на клавиатуре или при помощи указателя мышки. Таким образом будет производиться поворот сцены.

\section{Тестирование}

На рисунке \ref{img:inter} представлен интерфейс данном программы, на котором видно, что есть два поля ввода информации, а именно информации про количество этажей и частоту смены света. 

В каждом поле стоит ограничение на ввод информации.

В поле количества этажей можно ввести только цифры от 1 до 9 (для лучшей отрисовки сцены).

Частоту смены света можно задать в диапазоне от 1000 до 10000, где 1000 -- очень частая смена света, и 10000 -- редкая.

На рисунке \ref{img:test} представлен результат для входных данных: 3- количество этажей, 5000 - частота смена света (работу данного параметра можно посмотреть только при непосредственной непрерывной генерации сцены).

\img{70mm}{test}{Пример работы программы}


\section{Вывод}
В данном разделе были рассмотрены средства, с помощью которых было реализовано программное обеспечение, а также представлен листинг кода оптимизированного алгоритма обратной трассировки лучей.